Class EmptyBoundedBuffer (with classes PartialBoundedBuffer and FullBoundedBuffer) implements the bounded buffer in the actor model of computation.

As for class BoundedBuffer3 (in category Actalk-Ex-BoundedBuffer), a bounded buffer will resend requests for methods which are disabled. But as opposed to class BoundedBuffer3 such resending is not written within the body of methods. This is because behavior replacement may already explicitly specify which methods are enabled (and it implicitly disables any other one). Therefore there is not a single class for bounded behavior behavior but three of them. They correspond to the three possible states of a bounded buffer and associated enabled methods. Empty only enables put:. Full only enables get. Partial enables both of them. When accepting a message the replacement behavior is computed depending on the resulting state (empty, partial, full) of the bounded buffer.

Note that if the bounded buffer maximum size is 1, the partial state behavior will never be used.

In the (limit) case where the buffer is created with a maximum size of 0, there should be a specific behavior class disabling both put: and get. Although this case is of no use in practice, we may encounter it. Class NullBoundedBuffer defines such behavior. It defines everything necessary for a bounded buffer except accessing methods put: and get! However this class is also useful as an abstract/sharing superclass for classes EmptyBoundedBuffer and FullBoundedBuffer.

Therefore class EmptyBoundedBuffer is defined as a subclass of class NullBoundedBuffer.
Class EmptyBoundedBuffer only defines method put:.

Because disabled methods are simply unknown methods, we simply trap the doesNotUnderstand: error message and resend the original message. This means that any unknown method is a disabled method and that any wrong (e.g., mispelled) message would be indefinitely delayed.

After the initial step of class BoundedBuffer3 to implement synchronization, this further step is more modular (enabling methods is now explicitly stated through the behavior class. Methods do not include any synchronization code). But it still relies on resending of a message. (This consumes resources including time, and this breaks down the assumption of transmission ordering preservation).
Easy possible improvement is to control (whether a method is enabled or not) BEFORE message acceptance, in order to avoid such resending and to recover the assumption of transmission ordering preservation. See activity class EnabledSelectorsActorActivity in category Actalk-Ext-Actor-Ext, and resulting class EmptyBoundedBuffer2 in category Actalk-Ext-Actor-Ext-Ex.

This concept of enabled methods associated to the state of the behavior may also be expressed apart from the behavior replacement model, that is for standard active objects. This results in the concept of abstract state (as the set of enabled methods). See class AbstractStatesActivity within category Actalk-Synchro-AbsStates.

Note that although the behavior replacement concept allowes intra-object concurrency, here we cannot specify in a natural way that one get and one put: requests could be processed concurrently while disallowing concurrent put: or concurrent get. Let's take the example of a partial bounded buffer which accepts a put: request. It could concurrently accept a get request, but not another put until it has completed current put. If we specify a FullBoundedBuffer as immediate replacement behavior (although the buffer is not necessary becoming full) we temporarily disallow other put request, but within computation of further replacement behavior we have no way of checking completion of current put method, which is THE condition to accept another put method. In other words, in the bounded buffer example we have to deal with synchronization on state conditions as we did, but we also should deal with conditions for activation (one put a most and one get at most). The behavior replacement model can nicely specify state synchronization but is not good at activation conditions, although it may create intra-object concurrency. In the case of models with no intra-object concurrency (standard actor type, Abcl/1, Pool...) serialization of method acceptance ensures that there is at most one activation (implicit general mutual exclusion) which makes it safe but at the cost of restricting possible intra-object concurrency. See categories like Actalk-Synchro-Counters for a real full handling of activation synchronization and intra-object concurrency.